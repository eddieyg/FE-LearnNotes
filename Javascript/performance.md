# 性能优化

## 编码优化
### 数据读取
- 字面量与局部变量的访问速度较快，数组元素和对象成员相对较慢
- 对象的嵌套的越深，读取速度就越慢
- 手动释放无用变量引用
### DOM操作
- JS中访问DOM时间较长，可缓存到变量，重复引用
- DOM操作会引起重排与重绘，多次（适当）操作集中为一次性操作（防抖节流）
- js引擎执行栈会阻塞UI渲染，避免执行栈任务过长，影响页面渲染卡顿
- 避免事件监听对象过多，合理使用事件委托等

## 渲染路径优化
- HTML `script` 标签会阻塞DOM解析，放在body底部，或者放在head 使用按async、defer异步属性
- css也会阻塞DOM解析，避免使用@import串行加载
- 使用Preload进行CSS资源的预加载（不阻塞渲染）`<link rel="preload" href="" as="style">`

## 构建优化
- 代码的压缩、清除无用代码
- 公共代码分离
- 使用预编译（vue-loader模板编译成渲染函数）
- 使用字体图标，减少图片请求数量
- 使用资源CDN

## 缓存优化
- 本地存储不常变化的数据

### HTTP缓存
在HTTP缓存中，两者同时存在时，强制缓存优先级高于协商缓存
#### 强制缓存
如果资源的`Cache-Control`设置命中强缓存，浏览器便不会向服务器发送请求，而是直接读取缓存
- `public`：资源可以被任何对象（包括代理服务器）缓存
- `private`：资源只能被本地浏览器缓存（代理服务器不能缓存）
- `no-cache`：资源不被强缓存，但可以协商缓存
- `no-store`：资源不能被任何方式缓存
- `max-age`：设置资源的有效时间
#### 协商缓存
资源请求时携带 `ETag`、`Last-Modified` 标识；服务器判断未过期返回304不返回数据，浏览器再去读取缓存；如果已过期则返回资源数据
- `ETag`：资源的唯一标识符，请求头用`If-None-Match`字段携带；优先级高于`Last-Modified`
- `Last-Modified`：资源的修改时间，请求头用`If-Modified-Since`字段携带

## 策略优化
- 图片、资源、组件的懒加载和预加载
- 时间切片